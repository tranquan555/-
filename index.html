<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volume Shader Performance Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #fpsDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            font-family: sans-serif;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="fpsDisplay">FPS: 0</div>
    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const fpsDisplay = document.getElementById('fpsDisplay');
        let frameCount = 0;
        let lastTime = performance.now();

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 5, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            const shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
                vertexSource: `
                precision highp float;
                attribute vec3 position;
                uniform mat4 worldViewProjection;
                varying vec3 vPosition;

                void main(void) {
                  vPosition = position;
                  gl_Position = worldViewProjection * vec4(position, 1.0);
                }
              `,
              fragmentSource: `
                precision highp float;
                varying vec3 vPosition;
                uniform float time;
                uniform vec3 cameraPos;

                float hash(float n) { return fract(sin(n) * 43758.5453123); }

                float noise(vec3 p)
                {
                    vec3 ip = floor(p);
                    vec3 fp = fract(p);
                    
                    vec4 c00 = texture2D(noiseTex, (ip.xy + vec2(0, 0))/ 256.0);
                    vec4 c10 = texture2D(noiseTex, (ip.xy + vec2(1, 0))/ 256.0);
                    vec4 c01 = texture2D(noiseTex, (ip.xy + vec2(0, 1))/ 256.0);
                    vec4 c11 = texture2D(noiseTex, (ip.xy + vec2(1, 1))/ 256.0);

                    float n0 = mix(c00.r, c10.r, fp.x);
                    float n1 = mix(c01.r, c11.r, fp.x);
                    float n2 = mix(n0, n1, fp.y);
                    
                    
                    vec4 c00z = texture2D(noiseTex, (ip.zy + vec2(0, 0))/ 256.0);
                    vec4 c10z = texture2D(noiseTex, (ip.zy + vec2(1, 0))/ 256.0);
                    vec4 c01z = texture2D(noiseTex, (ip.zy + vec2(0, 1))/ 256.0);
                    vec4 c11z = texture2D(noiseTex, (ip.zy + vec2(1, 1))/ 256.0);

                    float n3 = mix(c00z.r, c10z.r, fp.y);
                    float n4 = mix(c01z.r, c11z.r, fp.y);
                    
                    float nz = mix(n3, n4, fp.z);
                    
                   return mix(n2, nz, fp.z) ;
                }


               float fbm(vec3 p)
              {
                  float f = 0.0;
                  f += noise(p) * 0.5;
                  p *= 2.0;
                  f += noise(p) * 0.25;
                   p *= 2.0;
                  f += noise(p) * 0.125;
                   p *= 2.0;
                   f += noise(p) * 0.0625;
                  p *= 2.0;
                   f += noise(p) * 0.03125;
                   
                  return f;
              }

               float volume(vec3 pos)
                {
                   vec3 p = pos * 3.0;
                  return fbm(p);
                }

                void main(void) {
                    vec3 rayDirection = normalize(vPosition - cameraPos);
                    float density = 0.0;
                   float stepSize = 0.01;

                   vec3 samplePos;
                   float maxSteps = 100.0;
                  for(float i = 0.0; i < maxSteps; i++){
                       samplePos = cameraPos + rayDirection * i * stepSize;
                       density+= volume(samplePos) * stepSize;
                       if(density > 1.0) break;
                    }
                   float alpha = min(density,1.0);
                  vec3 color = vec3(alpha);
                   gl_FragColor = vec4(color, alpha);
                }
              `
            },
            {
              attributes: ["position"],
              uniforms: ["worldViewProjection", "time", "cameraPos"],
            });


            const box = BABYLON.MeshBuilder.CreateBox("box", {size: 3}, scene);
            box.material = shaderMaterial;
            const noiseTex =  new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/PerlinNoise.png/300px-PerlinNoise.png", scene);
            shaderMaterial.setTexture("noiseTex", noiseTex);

            scene.onBeforeRenderObservable.add(() => {
                shaderMaterial.setFloat("time", engine.getDeltaTime() * 0.001);
                shaderMaterial.setVector3("cameraPos", camera.position);
                 frameCount++;
            });

            return scene;
        };

        const scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
             const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            if (deltaTime >= 1000) {
                const fps = Math.round(frameCount / (deltaTime / 1000));
                fpsDisplay.textContent = "FPS: " + fps;
                frameCount = 0;
                lastTime = currentTime;
            }

        });

        window.addEventListener('resize', function(){
            engine.resize();
        });
    </script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
</body>
</html>