<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Shift (Enhanced)</title>
    <style>
        body {
          margin: 0;
          overflow: hidden;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          background-color: #0a0a0a;
          font-family: 'Arial', sans-serif;
        }
        #gameContainer {
          position: relative;
        }
        canvas {
          display: block;
          background: #0a0a0a;
        }
        #menu {
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           text-align: center;
           color: white;
        }
        #playButton {
          background-color: #3498db;
          color: white;
          border: none;
          padding: 15px 30px;
          font-size: 1.2em;
           cursor: pointer;
           border-radius: 8px;
           transition: background-color 0.3s ease;
        }
        #playButton:hover {
          background-color: #2980b9;
       }
      .game-over-screen {
         position: absolute;
          top: 0;
        left: 0;
         width: 100%;
          height: 100%;
         background-color: rgba(0,0,0,0.8);
         color: white;
        display: none;
        flex-direction: column;
         align-items: center;
        justify-content: center;
         text-align: center;
         z-index: 10;
       }
      .game-over-screen h2{
        font-size: 2em;
        margin-bottom: 10px;
      }
      .game-over-screen button{
        background-color: #3498db;
         color: white;
         border: none;
       padding: 15px 30px;
          font-size: 1.2em;
         cursor: pointer;
        border-radius: 8px;
         transition: background-color 0.3s ease;
          margin-top: 10px;
        }
       .game-over-screen button:hover {
        background-color: #2980b9;
       }

       /* Styles cho inventory */
        #inventory {
        position: absolute;
         top: 10px;
          left: 10px;
         background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border: 2px solid #fff;
        z-index: 5;
          color: white;
         display: none;
        border-radius: 8px;
      }
      #inventory h2 {
        margin-top: 0;
      }
       #inventory ul {
         padding: 0;
        list-style: none;
      }

       #inventory ul li {
        margin-bottom: 5px;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <div id="menu">
        <h1>Cosmic Shift</h1>
        <button id="playButton">Play</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="game-over-screen" id="gameOverScreen">
        <h2 id="gameOverText">Game Over</h2>
        <p id="finalScore">Score:</p>
        <button id="restartButton">Restart</button>
    </div>
    <div id="inventory">
        <h2>Inventory</h2>
        <ul id="inventoryList">

        </ul>
    </div>
</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('gameContainer');
    const menu = document.getElementById('menu');
    const playButton = document.getElementById('playButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const gameOverText = document.getElementById('gameOverText');
    const finalScoreText = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const inventoryDiv = document.getElementById('inventory');
    const inventoryList = document.getElementById('inventoryList');
    let game;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const TILE_SIZE = 30;
    class Player {
      constructor(x, y) {
           this.x = x;
           this.y = y;
            this.size = TILE_SIZE;
            this.speed = 200;
            this.vx = 0;
            this.vy = 0;
           this.color = 'yellow';
           this.inventory = {};
           this.equippedWeapon = null;
           this.maxHealth = 100;
           this.health = this.maxHealth;
            this.level = 1;
            this.exp = 0;
            this.expToNextLevel = 100;
           this.init();
        }
     init() {
       document.addEventListener('keydown', (e) => {
          switch (e.key) {
             case 'ArrowUp':
                 this.vy = -this.speed;
                  break;
              case 'ArrowDown':
                  this.vy = this.speed;
                  break;
              case 'ArrowLeft':
                  this.vx = -this.speed;
                  break;
              case 'ArrowRight':
                 this.vx = this.speed;
                 break;
            case 'i':
                inventoryDiv.style.display = inventoryDiv.style.display === 'block' ? 'none' : 'block';
                 this.updateInventoryUI();
               break;
            case '1':
               this.equipWeapon('pistol');
                 break;
            case '2':
                this.equipWeapon('shotgun');
                 break;
             case '3':
               this.equipWeapon('flamethrower');
               break;

          }
         });
      document.addEventListener('keyup', (e) => {
        switch (e.key) {
            case 'ArrowUp':
           case 'ArrowDown':
               this.vy = 0;
               break;
            case 'ArrowLeft':
            case 'ArrowRight':
              this.vx = 0;
             break;
       }
      });
   }
  update(deltaTime, canvas) {
     this.x += this.vx * deltaTime;
     this.y += this.vy * deltaTime;
     if (this.x < 0) this.x = 0
     if (this.x > canvas.width - this.size) this.x = canvas.width - this.size
    if(this.y < 0) this.y = 0;
      if (this.y > canvas.height - this.size) this.y = canvas.height - this.size;
    }
     draw(ctx, cameraX, cameraY) {
         ctx.fillStyle = this.color;
         ctx.fillRect(this.x - cameraX, this.y-cameraY, this.size, this.size);
      }
       addItem(item, quantity) {
            if(this.inventory[item]) {
             this.inventory[item] += quantity;
            } else {
                this.inventory[item] = quantity;
            }
       }
       updateInventoryUI() {
            inventoryList.innerHTML = '';
           for(const item in this.inventory) {
                const li = document.createElement('li');
               li.textContent = `${item} x ${this.inventory[item]}`;
                inventoryList.appendChild(li);
           }
        }
        equipWeapon(weapon){
           if(Object.keys(this.inventory).includes(weapon)){
                this.equippedWeapon = weapon;
               console.log('equipped with', weapon)
            }else {
                 console.log("dont have weapon")
            }
        }
         addExp(amount){
             this.exp+= amount;
              while(this.exp >= this.expToNextLevel) {
               this.level++;
                this.exp -= this.expToNextLevel;
                  this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5)
               console.log('level up', this.level)
              }
         }
        takeDamage(damage){
          this.health -= damage;
            if(this.health <= 0){
               game.isGameOver = true;
               console.log('game over')
           }
       }
   }
    class Tile {
     constructor(x, y, type) {
        this.x = x;
           this.y = y;
        this.type = type;
       this.size = TILE_SIZE;
      }
      draw(ctx, cameraX, cameraY) {
        switch (this.type) {
             case 'dirt':
                 ctx.fillStyle = '#735545';
                  break;
             case 'stone':
               ctx.fillStyle = '#808080';
               break;
             case 'grass':
                ctx.fillStyle = '#32cd32';
               break;
            case 'air':
              return;
           default:
             ctx.fillStyle = 'black'
        }
        ctx.fillRect(this.x - cameraX, this.y - cameraY, this.size, this.size);
      }
  }
  class Enemy {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
       this.type = type;
        this.size = TILE_SIZE;
       this.speed = 80;
       this.vx = 0;
       this.vy = 0;
       this.health = 50;
    }
    update(deltaTime, player, cameraX, cameraY){
       const dx = player.x - this.x;
       const dy = player.y - this.y;
       const angle = Math.atan2(dy, dx);
        this.vx = Math.cos(angle) * this.speed;
       this.vy = Math.sin(angle) * this.speed;
      this.x += this.vx * deltaTime;
      this.y += this.vy * deltaTime;

      if (this.x < 0) this.x = 0
       if (this.x > canvas.width - this.size) this.x = canvas.width - this.size
      if(this.y < 0) this.y = 0;
    if (this.y > canvas.height - this.size) this.y = canvas.height - this.size;
    }
    draw(ctx, cameraX, cameraY){
        ctx.fillStyle = 'red';
       ctx.fillRect(this.x - cameraX, this.y-cameraY, this.size, this.size);
    }
     takeDamage(damage){
        this.health -= damage;
         if(this.health <=0){
             return true;
         }
         return false;
     }
 }
  class Bullet {
    constructor(x, y, angle, speed, damage) {
     this.x = x;
     this.y = y;
     this.angle = angle;
      this.speed = speed;
      this.size = 5;
      this.damage = damage;
    }
      update(deltaTime){
          this.x += Math.cos(this.angle) * this.speed * deltaTime;
          this.y += Math.sin(this.angle) * this.speed * deltaTime;
     }
     draw(ctx, cameraX, cameraY){
          ctx.fillStyle = 'white';
          ctx.beginPath();
        ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2)
        ctx.fill();
         ctx.closePath();
       }
  }
  class SoundManager {
     constructor() {
        this.backgroundMusic = new Audio('./assets/bgm.mp3');
         this.crashSound = new Audio('./assets/crash.mp3');
         this.portalSound = new Audio('./assets/portal.mp3');
          this.levelUpSound = new Audio('./assets/level-up.mp3');
         this.gunshotSound = new Audio('./assets/gunshot.mp3');
        this.backgroundMusic.loop = true;
        this.backgroundMusic.volume = 0.5;
    }
   playBackgroundMusic() {
       this.backgroundMusic.play();
   }
   stopBackgroundMusic(){
      this.backgroundMusic.pause();
       this.backgroundMusic.currentTime = 0;
   }
   playCrash() {
      this.crashSound.play();
    }
     playPortal() {
       this.portalSound.play();
    }
   playLevelUp(){
       this.levelUpSound.play();
    }
    playGunShot(){
       this.gunshotSound.play();
     }
    }
  class StorageManager {
    constructor() {
       this.storageKey = 'cosmicShiftSave';
       }
    saveGame(data) {
         try {
            const json = JSON.stringify(data);
         localStorage.setItem(this.storageKey, json);
          }
          catch(e) {
              console.error('Error saving game to local storage', e);
          }
       }
      loadGame() {
       try{
        const json = localStorage.getItem(this.storageKey);
          return json ? JSON.parse(json) : null;
     }catch (e) {
      console.error('Error loading game from local storage', e);
       }
         return null;
    }
    }
 class CombatSystem {
      constructor(){

      }
       calculateDamage(attacker, defender){
         return 10;
       }
 }
 class Game {
        constructor(canvas, ctx) {
           this.canvas = canvas;
          this.ctx = ctx;
          this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
          this.enemies = [];
          this.bullets = [];
          this.world = this.generateWorld();
          this.soundManager = new SoundManager();
           this.storageManager = new StorageManager();
          this.combatSystem = new CombatSystem();
           this.score = 0;
          this.lastTime = 0;
          this.isGameOver = false;
            this.level = 1;
           this.spawnTimer = 0;
            this.enemySpawnTimer = 0;
           this.cameraX = 0;
          this.cameraY = 0;
            this.enemySpeed = 80;
            this.init();
          this.soundManager.playBackgroundMusic();
          this.lastMousePos = {x: 0, y: 0}
      }

      init() {
        const savedData = this.storageManager.loadGame();
          if(savedData) {
             this.score = savedData.score;
              this.level = savedData.level;
          }
           this.canvas.addEventListener('mousedown', (e) => {
               this.handleMouseClick(e);
          });

       }

      start() {
        this.isGameOver = false;
         gameOverScreen.style.display = 'none';
        this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
        this.enemies = [];
       this.bullets = [];
          this.score = 0;
        this.lastTime = 0;
         this.level = 1;
         this.spawnTimer = 0;
        this.enemySpawnTimer = 0;
       this.cameraX = 0;
       this.cameraY = 0;
         this.enemySpeed = 80;
         this.gameLoop();
     }

      gameLoop(timestamp) {
         if (this.isGameOver) {
              this.drawGameOver();
              this.soundManager.stopBackgroundMusic();
            return;
         }
          const deltaTime = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
          this.update(deltaTime);
          this.render();
           requestAnimationFrame(this.gameLoop.bind(this));
       }
        update(deltaTime) {
          this.spawnTimer += deltaTime;
          if (this.spawnTimer > 2 - this.level * 0.1) {
              this.spawnItem(this.getRandomTilePos());
           this.spawnTimer = 0;
         }
            this.enemySpawnTimer += deltaTime;
         if(this.enemySpawnTimer > 3 - this.level * 0.1){
              this.spawnEnemy(this.getRandomTilePos());
            this.enemySpawnTimer = 0;
         }
           this.player.update(deltaTime, this.canvas);
           this.enemies.forEach(enemy => enemy.update(deltaTime, this.player, this.cameraX, this.cameraY));
            this.bullets.forEach(bullet => bullet.update(deltaTime));
         this.checkCollisions();
            this.checkBulletCollision();
          this.updateCamera();

           if (this.score > this.level * 50) {
                this.level++;
                this.enemySpeed += 10;
                this.soundManager.playLevelUp();
           }
        }
      render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
           this.drawBackground();
          this.drawWorld();
           this.enemies.forEach(enemy => enemy.draw(this.ctx, this.cameraX, this.cameraY));
         this.player.draw(this.ctx, this.cameraX, this.cameraY);
            this.bullets.forEach(bullet => bullet.draw(this.ctx, this.cameraX, this.cameraY));
            this.drawHud();

      }
      drawBackground() {
         this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
     }
      drawWorld(){
        for(const tile of this.world){
             tile.draw(this.ctx, this.cameraX, this.cameraY);
        }
     }

        drawHud() {
           this.ctx.fillStyle = 'white';
          this.ctx.font = '20px Arial';
           this.ctx.fillText(`Score: ${this.score}`, 20, 30);
           this.ctx.fillText(`Level: ${this.level}`, 20, 55);
          this.ctx.fillText(`Health: ${this.player.health}`, 20, 80);
        this.ctx.fillText(`Exp: ${this.player.exp} / ${this.player.expToNextLevel}`, 20, 105)
        }
      generateWorld() {
         const world = [];
        const worldWidth = 50;
          const worldHeight = 20;

           for (let y = 0; y < worldHeight; y++) {
              for (let x = 0; x < worldWidth; x++) {
                  let type = 'air';

                if (y > worldHeight -4) {
                 if(y === worldHeight -1){
                        type = 'grass'
                   }else{
                         type = 'dirt';
                     }
               }else if (Math.random() < 0.2) {
                     type = 'stone';
                  }
                world.push(new Tile(x * TILE_SIZE, y * TILE_SIZE, type));
                }
           }
         return world;
        }
     getRandomTilePos(){
           const validPositions = this.world.filter(tile => tile.type === 'air');
            if(validPositions.length > 0){
              const randomPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                 return {
                     x: randomPos.x,
                     y: randomPos.y
                 }
           }
           return {x: this.canvas.width /2, y: this.canvas.height /2}
       }
      spawnEnemy(pos){
            this.enemies.push(new Enemy(pos.x, pos.y));
      }
      spawnItem(pos){
        const itemTypes = ['stone', 'wood'];
        const randomItem = itemTypes[Math.floor(Math.random() * itemTypes.length)];
        this.player.addItem(randomItem, 1);
      }
    checkCollisions() {
        this.enemies.forEach((enemy, enemyIndex) => {
          const dx = this.player.x - enemy.x;
            const dy = this.player.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.player.size + enemy.size) {
               const damage = this.combatSystem.calculateDamage(enemy, this.player);
              this.player.takeDamage(damage);
                console.log('player took damage')
              if(this.isGameOver) {
                    this.soundManager.playCrash();
                 this.storageManager.saveGame({
                       score: this.score,
                      level: this.level
                  });
                return;
                }
              }
        });
    }

    handleMouseClick(event) {
        this.lastMousePos = {
          x: event.clientX,
          y: event.clientY
       }

        if(this.player.equippedWeapon) {
          const weapon = this.player.equippedWeapon;
          switch (weapon) {
               case 'pistol':
                 this.fireBullet(10, 800, 10);
                  break;
            case 'shotgun':
                  this.fireBullet(15, 600, 10);
                this.fireBullet(15, 600, 10, Math.PI/10);
                  this.fireBullet(15, 600, 10, -Math.PI/10);
                 break;
             case 'flamethrower':
               this.fireBullet(5, 100, 5, Math.PI/12);
                  this.fireBullet(5, 100, 5, -Math.PI/12);
                  this.fireBullet(5, 100, 5);
                  break;

             }
         }
      }
        fireBullet(size = 10, speed = 10, damage = 10, angleOffset = 0){
         const dx =  this.lastMousePos.x - (this.player.x + this.cameraX) ;
            const dy =  this.lastMousePos.y - (this.player.y + this.cameraY);
          const angle = Math.atan2(dy, dx) + angleOffset;
        const bullet = new Bullet(this.player.x, this.player.y, angle, speed, damage);
            this.bullets.push(bullet);
         this.soundManager.playGunShot();
      }
   checkBulletCollision() {
       this.bullets.forEach((bullet, bulletIndex) => {
          this.enemies.forEach((enemy, enemyIndex) => {
              const dx = bullet.x - enemy.x;
           const dy = bullet.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < bullet.size + enemy.size) {
                  if(enemy.takeDamage(bullet.damage)) {
                      this.enemies.splice(enemyIndex, 1);
                    this.score+= 10;
                    this.player.addExp(20);
                  }
                   this.bullets.splice(bulletIndex, 1);
                }
           });
        if(bullet.x < -100 || bullet.x > this.canvas.width + 100 || bullet.y < -100 || bullet.y > this.canvas.height + 100){
                this.bullets.splice(bulletIndex, 1);
          }

        })

    }

  updateCamera() {
        this.cameraX = this.player.x - this.canvas.width / 2;
        this.cameraY = this.player.y - this.canvas.height / 2;
     }

      drawGameOver() {
         gameOverScreen.style.display = 'flex';
          gameOverText.textContent = 'Game Over';
           finalScoreText.textContent = `Final Score: ${this.score}`;
        }
    }
    //Setup sự kiện
    playButton.addEventListener('click', () => {
       menu.style.display = 'none';
         if(!game){
            game = new Game(canvas, ctx);
          }
        game.start();
  });
  restartButton.addEventListener('click', () => {
    if(game){
       game.start();
       }
  });
  // Tải âm thanh khi trang web được load
 window.addEventListener('load', () => {
    const soundManager = new SoundManager();
     soundManager.playBackgroundMusic(); // phát nhạc nền khi trang được load
    soundManager.stopBackgroundMusic(); // đảm bảo nhạc nền chưa chạy khi game chưa start
    });
</script>
</body>
</html>
